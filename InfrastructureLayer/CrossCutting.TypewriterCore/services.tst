${
    // Enable extension methods by adding using Typewriter.Extensions.*
    using Typewriter.Extensions.Types;
    using Typewriter.Extensions.WebApi;

    // Uncomment the constructor to change template settings.
    Template(Settings settings)
    {
        settings.IncludeProject("DDDReflection");
        settings.OutputFilenameFactory = file => 
        {
            var finalFileName = file.Name.Replace("Controller.cs", "").ToLower();

            return $"..\\..\\..\\FE\\ALDA-UI\\src\\app\\core\\services\\" + $"{finalFileName}.service.ts"; 
     
        };
    }

    // Custom extension methods can be used in the template by adding a $ prefix e.g. $LoudName
    string LoudName(Property property)
    {
        return property.Name.ToUpperInvariant();
    }

     // Change BaseApiController to Service
    string ServiceName(Class c) => c.Name.Replace("Controller", "Service");

    //get the service route
    static string ServiceRoute(Class c){ 
        Attribute attri = c.Attributes.SingleOrDefault(a => a.Name == "Route");
        if(attri != null)
        {
            return attri.Value.Replace("[controller]", c.Name.Replace("Controller", string.Empty).ToLowerInvariant());
        }

        return "missing route attribute";
    }

    // Turn IActionResult into void
    static string ReturnType(Method objMethod) 
    {
        if(objMethod.Type.Name != "IActionResult")
        {
            return objMethod.Type.Name;
        }
   
        Attribute attri = objMethod.Attributes.SingleOrDefault(a => a.Name == "ProducesResponseType");
        if(attri != null)
        {      
            return attri.Arguments[0].TypeValue;
        }
                
        if((objMethod.Parameters.Where(x => !x.Type.IsPrimitive).FirstOrDefault() != null))
        {
            return objMethod.Parameters.Where(x => !x.Type.IsPrimitive).FirstOrDefault().Name;
        }
        else
        {
            return "void";
        }    
    }

    // Get the non primitive paramaters so we can create the Imports at the
    // top of the service
    string ImportsList(Class objClass)
    {
        var ImportsOutput = "";
        // Get the methods in the Class
        var objMethods = objClass.Methods;
        // Loop through the Methdos in the Class
        foreach(Method objMethod in objMethods)
        {
            if(!objMethod.Type.IsPrimitive && !ImportsOutput.Contains(objMethod.Type.ClassName())){
                ImportsOutput = objMethod.Type.ClassName();
            }
            // Loop through each Parameter in each method
            foreach(Parameter objParameter in objMethod.Parameters)
            {
                // If the Paramater is not prmitive we need to add this to the Imports
                if(!objParameter.Type.IsPrimitive && !ImportsOutput.Contains(objParameter.Name)){
                    ImportsOutput = objParameter.Name;
                }
            }
        }
        // Notice: As of now this will only return one import
         return string.IsNullOrWhiteSpace(ImportsOutput) ? string.Empty : $"import {{ { ImportsOutput } }} from '@app/models';";
    }
    // Format the method based on the return type
    string MethodFormat(Method objMethod)
    {
        string url = objMethod.Url().ToLowerInvariant().Replace(Template.ServiceRoute((Class)objMethod.Parent).ToLowerInvariant(), string.Empty);
        //string urlParamenters = url.Replace("${", string.Empty).Replace("}", string.Empty).Replace("/", string.Empty);
       // string allMethods = objMethod.Parameters.Select((p)=> p.name).Aggregate((a,b) => $"{a} , {b}");

        if(!string.IsNullOrWhiteSpace(url))
        {
            url = $" + `{url}`";
        }

        if(objMethod.HttpMethod() == "get"){
            return  $"<{objMethod.Type.Name}>(API_BASE_URL{url})";
        } 
       
        if(objMethod.HttpMethod() == "post"){
            return  $"<{Template.ReturnType(objMethod)}>(API_BASE_URL, {objMethod.Parameters[0].name})";
        }
        if(objMethod.HttpMethod() == "patch"){
            return  $"<{Template.ReturnType(objMethod)}>(API_BASE_URL{url}, {objMethod.Parameters[1].name})";
        }
        if(objMethod.HttpMethod() == "put"){
            return  $"(API_BASE_URL, {objMethod.Parameters[1].name})";
        }
        if(objMethod.HttpMethod() == "delete"){
            return  $"(API_BASE_URL)";
        }
        
        return  $"";
    }
}//The do not modify block below is intended for the outputted typescript files... 
//*************************DO NOT MODIFY**************************
//
//THESE FILES ARE AUTOGENERATED WITH TYPEWRITER AND ANY MODIFICATIONS MADE HERE WILL BE LOST
//PLEASE VISIT http://frhagn.github.io/Typewriter/ TO LEARN MORE ABOUT THIS VISUAL STUDIO EXTENSION
//
//*************************DO NOT MODIFY**************************

import { throwError, Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { environment } from '@env/environment';
$Classes(:BaseApiController)[$ImportsList
// ReSharper disable once InconsistentNaming
const API_BASE_URL: string = environment.apis.core + '$ServiceRoute';

@Injectable()
export class $ServiceName {
    constructor(private httpClient: HttpClient) { }        
    $Methods[
    // $HttpMethod: $Url      
    public $name($Parameters[$name: $Type][, ]): Observable<$ReturnType> {
        return this.httpClient.$HttpMethod$MethodFormat
            .pipe(catchError(e => this.handleError(e)));
    }]

    // Utility
    private handleError(error: HttpErrorResponse) {
        if (error.error instanceof ErrorEvent) {
          // A client-side or network error occurred. Handle it accordingly.
          console.error('An error occurred:', error.error.message);
        } else {
          // The backend returned an unsuccessful response code.
          // The response body may contain clues as to what went wrong,
          console.error(
            `Backend returned code ${error.status}, ` +
            `body was: ${error.error}`);
        }
        // return an observable with a user-facing error message
        return throwError(error ||
          'Something bad happened; please try again later.');
    };
}]
